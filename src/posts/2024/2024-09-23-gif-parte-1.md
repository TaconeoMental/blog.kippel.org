---
layout: post
title: "Desarrollando una librería gráfica para sistemas embebidos: Parte 1"
tags: draft dev C eGIF
---

## Introducción

Hace un par de años, en 2022, escribí una librería para crear interfaces de
usuario gráficas en pantallas OLED monocromáticas, particularmente en sistemas
embebidos. Fue un proyecto chico que eventualmente abandoné, pero nunca se me
fueron las ganas de reescribirlo desde 0, tomando consideraciones adicionales
en la fase de diseño y adaptándolo a algunos nuevos requerimientos que tengo.
Entonces, luego de todo este tiempo, he decidido volverlo realidad.

En esta serie de publicaciones voy a documentar el proceso completo de
desarrollo de esta nueva librería, desde la fase de diseño hasta las últimas
pruebas que haga en circuitos reales.

La librería original se llamaba **GIF** (Graphical Interface Framework), así
que decidí ponerle **eGIF** (Embedded Graphical Interface Framework) a este
nuevo proyecto. El nombre me suena a *electronic GIF* ('e' como en eInk) o
*extended GIF* y sigue conservando el significado coherente de la sigla. Parece
una tontera, pero no soy fan de cambiar nombres a mitad de camino.

## Características de la Librería

Hay algunas cosas básicas que sí o sí deben cumplirse. Todas estas aplicaban
a mi proyecto original, así que sé que no son tan descabelladas:
- **Debe estar escrita en C**: Es para sistemas embebidos, es lo más natural.
- **Debe usar FreeRTOS**: Como el nombre dice, **eGIF** es un framework, no solo una
    librería. No pretendo que se use solamente para crear componentes gráficos
    o widgets en una pantalla, sino que sea un ecosistema completo que permita
    gestionar aplicaciones, inputs, eventos asíncronos, widgets, etc. La forma
    más fácil de hacer eso es desarrollando todo en base a algún RTOS y
    diseñándolo de forma que los proyectos se construyan sobre **eGIF** y no al
    revés. Además, FreeRTOS es el único RTOS con el que he trabajado :).
- **El diseño debe ser modular**: La librería debe permitir integrar nuevas
    funcionalidades de forma natural y coherente, así como ofrecer una API que
    facilite la creación de componentes nativos. Algunos ejemplos de esto:
    Creación de nuevos Widgets, definición de eventos personalizados, creación
    de servicios nuevos (e.g. un servicios que reciba inputs de botones
    físicos), creación de wrappers para otros tipos de pantallas, etc.


## GUIs, OOP y C

Por diseño, una interfaz gráfica exige algún grado de orientación a objetos.
En particular, los *widgets* -y su naturaleza modular- no podrían existir si
no fuera por el polimorfismo, y la creación (intuitiva) de componentes sería
difícil de implementar sin algún tipo de herencia. Si bien implementar estas
cosas en C no es ninguna novedad, es muy fácil perderse con este nuevo nivel de
abstracción, combinando programación procedural con un enfoque orientado a
objetos.

### Polimorfismo

TODO, explicar ejemplo

{% highlight c %}
typedef struct Widget
{
    uint8_t x;
    uint8_t y;
    uint8_t width;
    uint8_t height;

    void *model;

    // Callback de función que dibuja el widget
    void (*WidgetDrawCallback)(Display *display, Widget *widget);
} Widget;

// Custom Widget
#define MAX_LABEL_TEXT_LENGTH 20

typedef struct LabelModel
{
    char text[MAX_LABEL_TEXT_LENGTH];
    bool has_round_border;
} LabelModel;

typedef struct Label
{
    Widget *widget;
    LabelModel *model;
} Label;

void label_draw_callback(Display *display, Widget *widget)
{
    uint8_t default_radius = 0.20 * widget->width;

    // Cast al void* para recuperar el tipo
    LabelModel *label = (LabelModel *) widget->model;

    if (label->has_round_border)
    {
        display_draw_round_frame(display,
                                 widget->x,
                                 widget->y,
                                 widget->width,
                                 widget->height,
                                 default_radius);
    } else {
        display_draw_normal_frame(display,
                                  widget->x,
                                  widget->y,
                                  widget->width,
                                  widget->height,
                                  default_radius);

    }
    display_draw_str(display, label->text);
}
{% endhighlight %}


### Herencia

TODO


## Estructura Básica

Ya tengo la estructura base un poco armada desde el proyecto anterior, aunque
igual quiero ser un poco escéptico de mis ideas pasadas.

### Servicios

La estructura más básica en **eGIF** son los servicios. En jerga de FreeRTOS, los
servicios son los Tasks con mayor prioridad en la aplicación. Por defecto, solo
existe el servicio **GUI** que se encarga de configurar la pantalla y dibujar
los elementos correspondientes. Además, cuenta con una *Queue* para que otros
servicios puedan comunicar eventos e interacturar con el contenido de la
pantalla. Por ejemplo, se podría crear un servicio que traduzca el input de
botones físicos en eventos de tecleo. También se podría generar un servicio que
envíe eventos de "timeout" cada cierto tiempo para apagar la pantalla si no ha
habido actividad.

{% asciiart %}
   .-----------. .-----------.
   | Servicio1 | | Servicio2 |
   '-----.-----' '-----.-----'
         |             |
         |           .-'---------.
  .------|-----------|-----------|------------------.
  | .----v----. .----v----. .----v----.             |
.-| | evento1 | | evento2 | | evento3 |             |
| | '---------' '---------' '---------'             |
| '-------------------------------------------------'
|                 Cola de Eventos
|  .--------------. 
'->| Servicio GUI |
   '--------------'
{% endasciiart %}
